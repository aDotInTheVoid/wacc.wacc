5 begin begin
4 bool bool
7 identifier isAlpha
1 lparen (
4 char char
1 identifier c
1 rparen )
2 is is
6 return return
1 lparen (
1 identifier c
2 ge >=
3 char 'a'
2 and &&
1 identifier c
2 le <=
3 char 'z'
1 rparen )
2 or ||
1 lparen (
1 identifier c
2 ge >=
3 char 'A'
2 and &&
1 identifier c
2 le <=
3 char 'Z'
1 rparen )
2 or ||
1 identifier c
2 eq ==
3 char '_'
3 end end
4 bool bool
7 identifier isDigit
1 lparen (
4 char char
1 identifier c
1 rparen )
2 is is
6 return return
1 identifier c
2 ge >=
3 char '0'
2 and &&
1 identifier c
2 le <=
3 char '9'
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
9 identifier wacc_fail
1 lparen (
6 string string
4 identifier file
1 comma ,
3 int int
4 identifier line
1 comma ,
6 string string
6 identifier reason
1 rparen )
2 is is
5 print print
4 identifier file
1 semi ;
5 print print
3 string ":"
1 semi ;
5 print print
4 identifier line
1 semi ;
5 print print
3 string " "
1 semi ;
5 print print
6 identifier reason
1 semi ;
7 println println
2 string ""
1 semi ;
6 return return
4 null null
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
10 identifier lexer_ctor
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 comma ,
3 int int
5 identifier start
1 comma ,
3 int int
7 identifier current
1 comma ,
3 int int
12 identifier logical_line
1 rparen )
2 is is
3 int int
8 identifier ll__ctor
1 assign =
12 identifier logical_line
1 semi ;
3 int int
8 identifier rl__ctor
1 assign =
7 identifier current
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
7 identifier l__ctor
1 assign =
7 newpair newpair
1 lparen (
8 identifier ll__ctor
1 comma ,
8 identifier rl__ctor
1 rparen )
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier lr__ctor
1 assign =
8 identifier sentinal
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
9 identifier lrr__ctor
1 assign =
6 identifier source
1 semi ;
3 int int
9 identifier rrr__ctor
1 assign =
5 identifier start
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
8 identifier rr__ctor
1 assign =
7 newpair newpair
1 lparen (
9 identifier lrr__ctor
1 comma ,
9 identifier rrr__ctor
1 rparen )
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
7 identifier r__ctor
1 assign =
7 newpair newpair
1 lparen (
8 identifier lr__ctor
1 comma ,
8 identifier rr__ctor
1 rparen )
1 semi ;
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __ctor
1 assign =
7 newpair newpair
1 lparen (
7 identifier l__ctor
1 comma ,
7 identifier r__ctor
1 rparen )
1 semi ;
6 return return
6 identifier __ctor
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
10 identifier lexer_dtor
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
5 identifier lself
1 assign =
3 fst fst
4 identifier self
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
5 identifier rself
1 assign =
3 snd snd
4 identifier self
1 semi ;
3 int int
6 identifier llself
1 assign =
3 fst fst
5 identifier lself
1 semi ;
3 int int
6 identifier rlself
1 assign =
3 snd snd
5 identifier lself
1 semi ;
4 free free
5 identifier lself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
6 identifier lrself
1 assign =
3 fst fst
5 identifier rself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
6 identifier rrself
1 assign =
3 snd snd
5 identifier rself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
7 identifier lrrself
1 assign =
3 fst fst
6 identifier rrself
1 semi ;
3 int int
7 identifier rrrself
1 assign =
3 snd snd
6 identifier rrself
1 semi ;
4 free free
6 identifier rrself
1 semi ;
4 free free
5 identifier rself
1 semi ;
4 free free
4 identifier self
1 semi ;
6 return return
4 null null
3 end end
6 string string
14 identifier token_type_str
1 lparen (
3 int int
3 identifier __e
1 rparen )
2 is is
2 if if
3 identifier __e
1 lt <
2 number 28
4 then then
2 if if
3 identifier __e
1 lt <
2 number 14
4 then then
2 if if
3 identifier __e
1 lt <
1 number 7
4 then then
2 if if
3 identifier __e
1 lt <
1 number 3
4 then then
2 if if
3 identifier __e
1 lt <
1 number 1
4 then then
2 if if
3 identifier __e
2 eq ==
1 number 0
4 then then
6 return return
12 string "identifier"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
1 number 2
4 then then
2 if if
3 identifier __e
2 eq ==
1 number 1
4 then then
6 return return
8 string "number"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
1 number 2
4 then then
6 return return
5 string "eof"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
1 number 5
4 then then
2 if if
3 identifier __e
1 lt <
1 number 4
4 then then
2 if if
3 identifier __e
2 eq ==
1 number 3
4 then then
6 return return
7 string "begin"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
1 number 4
4 then then
6 return return
6 string "bool"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
1 number 6
4 then then
2 if if
3 identifier __e
2 eq ==
1 number 5
4 then then
6 return return
6 string "call"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
1 number 6
4 then then
6 return return
6 string "char"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 10
4 then then
2 if if
3 identifier __e
1 lt <
1 number 8
4 then then
2 if if
3 identifier __e
2 eq ==
1 number 7
4 then then
6 return return
5 string "chr"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
1 number 9
4 then then
2 if if
3 identifier __e
2 eq ==
1 number 8
4 then then
6 return return
4 string "do"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
1 number 9
4 then then
6 return return
6 string "done"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 12
4 then then
2 if if
3 identifier __e
1 lt <
2 number 11
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 10
4 then then
6 return return
6 string "else"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 11
4 then then
6 return return
5 string "end"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 13
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 12
4 then then
6 return return
6 string "exit"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 13
4 then then
6 return return
7 string "false"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 21
4 then then
2 if if
3 identifier __e
1 lt <
2 number 17
4 then then
2 if if
3 identifier __e
1 lt <
2 number 15
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 14
4 then then
6 return return
4 string "fi"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 16
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 15
4 then then
6 return return
6 string "free"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 16
4 then then
6 return return
5 string "fst"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 19
4 then then
2 if if
3 identifier __e
1 lt <
2 number 18
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 17
4 then then
6 return return
4 string "if"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 18
4 then then
6 return return
5 string "int"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 20
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 19
4 then then
6 return return
4 string "is"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 20
4 then then
6 return return
5 string "len"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 24
4 then then
2 if if
3 identifier __e
1 lt <
2 number 22
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 21
4 then then
6 return return
9 string "newpair"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 23
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 22
4 then then
6 return return
6 string "null"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 23
4 then then
6 return return
5 string "ord"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 26
4 then then
2 if if
3 identifier __e
1 lt <
2 number 25
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 24
4 then then
6 return return
6 string "pair"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 25
4 then then
6 return return
7 string "print"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 27
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 26
4 then then
6 return return
9 string "println"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 27
4 then then
6 return return
6 string "read"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 42
4 then then
2 if if
3 identifier __e
1 lt <
2 number 35
4 then then
2 if if
3 identifier __e
1 lt <
2 number 31
4 then then
2 if if
3 identifier __e
1 lt <
2 number 29
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 28
4 then then
6 return return
8 string "return"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 30
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 29
4 then then
6 return return
6 string "skip"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 30
4 then then
6 return return
5 string "snd"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 33
4 then then
2 if if
3 identifier __e
1 lt <
2 number 32
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 31
4 then then
6 return return
8 string "string"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 32
4 then then
6 return return
6 string "then"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 34
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 33
4 then then
6 return return
6 string "true"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 34
4 then then
6 return return
7 string "while"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 38
4 then then
2 if if
3 identifier __e
1 lt <
2 number 36
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 35
4 then then
6 return return
8 string "lparen"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 37
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 36
4 then then
6 return return
8 string "rparen"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 37
4 then then
6 return return
8 string "assign"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 40
4 then then
2 if if
3 identifier __e
1 lt <
2 number 39
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 38
4 then then
6 return return
6 string "semi"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 39
4 then then
6 return return
7 string "comma"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 41
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 40
4 then then
6 return return
9 string "lsquare"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 41
4 then then
6 return return
9 string "rsquare"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 49
4 then then
2 if if
3 identifier __e
1 lt <
2 number 45
4 then then
2 if if
3 identifier __e
1 lt <
2 number 43
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 42
4 then then
6 return return
5 string "not"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 44
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 43
4 then then
6 return return
7 string "minus"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 44
4 then then
6 return return
7 string "times"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 47
4 then then
2 if if
3 identifier __e
1 lt <
2 number 46
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 45
4 then then
6 return return
5 string "div"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 46
4 then then
6 return return
5 string "mod"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 48
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 47
4 then then
6 return return
6 string "plus"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 48
4 then then
6 return return
4 string "gt"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 52
4 then then
2 if if
3 identifier __e
1 lt <
2 number 50
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 49
4 then then
6 return return
4 string "ge"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 51
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 50
4 then then
6 return return
4 string "lt"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 51
4 then then
6 return return
4 string "le"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 54
4 then then
2 if if
3 identifier __e
1 lt <
2 number 53
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 52
4 then then
6 return return
4 string "eq"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 53
4 then then
6 return return
4 string "ne"
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier __e
1 lt <
2 number 55
4 then then
2 if if
3 identifier __e
2 eq ==
2 number 54
4 then then
6 return return
5 string "and"
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier __e
2 eq ==
2 number 55
4 then then
6 return return
4 string "or"
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
1 semi ;
4 exit exit
1 number 1
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
10 identifier token_ctor
1 lparen (
3 int int
4 identifier type
1 comma ,
3 int int
5 identifier start
1 comma ,
3 int int
6 identifier length
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
6 identifier source
1 rparen )
2 is is
3 int int
8 identifier ll__ctor
1 assign =
4 identifier type
1 semi ;
3 int int
8 identifier rl__ctor
1 assign =
6 identifier length
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
7 identifier l__ctor
1 assign =
7 newpair newpair
1 lparen (
8 identifier ll__ctor
1 comma ,
8 identifier rl__ctor
1 rparen )
1 semi ;
3 int int
8 identifier lr__ctor
1 assign =
5 identifier start
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier rr__ctor
1 assign =
6 identifier source
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
1 rparen )
7 identifier r__ctor
1 assign =
7 newpair newpair
1 lparen (
8 identifier lr__ctor
1 comma ,
8 identifier rr__ctor
1 rparen )
1 semi ;
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __ctor
1 assign =
7 newpair newpair
1 lparen (
7 identifier l__ctor
1 comma ,
7 identifier r__ctor
1 rparen )
1 semi ;
6 return return
6 identifier __ctor
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
10 identifier token_dtor
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
5 identifier lself
1 assign =
3 fst fst
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier rself
1 assign =
3 snd snd
4 identifier self
1 semi ;
3 int int
6 identifier llself
1 assign =
3 fst fst
5 identifier lself
1 semi ;
3 int int
6 identifier rlself
1 assign =
3 snd snd
5 identifier lself
1 semi ;
4 free free
5 identifier lself
1 semi ;
3 int int
6 identifier lrself
1 assign =
3 fst fst
5 identifier rself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
6 identifier rrself
1 assign =
3 snd snd
5 identifier rself
1 semi ;
4 free free
5 identifier rself
1 semi ;
4 free free
4 identifier self
1 semi ;
6 return return
4 null null
3 end end
3 int int
15 identifier identifier_kind
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
3 identifier str
1 comma ,
3 int int
5 identifier start
1 comma ,
3 int int
4 identifier lenn
1 rparen )
2 is is
2 if if
4 identifier lenn
2 le <=
1 number 3
4 then then
2 if if
4 identifier lenn
2 le <=
1 number 2
4 then then
2 if if
4 identifier lenn
2 eq ==
1 number 2
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'f'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'd'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'd'
1 comma ,
3 char 'o'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
1 number 8
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'f'
1 comma ,
3 char 'i'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 14
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 1
1 rsquare ]
2 le <=
3 char 'f'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'i'
1 comma ,
3 char 'f'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 17
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'i'
1 comma ,
3 char 's'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 19
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
4 identifier lenn
2 eq ==
1 number 3
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'f'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'c'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'c'
1 comma ,
3 char 'h'
1 comma ,
3 char 'r'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
1 number 7
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'e'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'e'
1 comma ,
3 char 'n'
1 comma ,
3 char 'd'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 11
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'f'
1 comma ,
3 char 's'
1 comma ,
3 char 't'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 16
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'l'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'i'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'i'
1 comma ,
3 char 'n'
1 comma ,
3 char 't'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 18
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'l'
1 comma ,
3 char 'e'
1 comma ,
3 char 'n'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 20
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'o'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'o'
1 comma ,
3 char 'r'
1 comma ,
3 char 'd'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 23
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 's'
1 comma ,
3 char 'n'
1 comma ,
3 char 'd'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 30
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
4 identifier lenn
2 le <=
1 number 4
4 then then
2 if if
4 identifier lenn
2 eq ==
1 number 4
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'e'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'c'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'b'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'b'
1 comma ,
3 char 'o'
1 comma ,
3 char 'o'
1 comma ,
3 char 'l'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
1 number 4
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 1
1 rsquare ]
2 le <=
3 char 'a'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'c'
1 comma ,
3 char 'a'
1 comma ,
3 char 'l'
1 comma ,
3 char 'l'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
1 number 5
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'c'
1 comma ,
3 char 'h'
1 comma ,
3 char 'a'
1 comma ,
3 char 'r'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
1 number 6
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'd'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'd'
1 comma ,
3 char 'o'
1 comma ,
3 char 'n'
1 comma ,
3 char 'e'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
1 number 9
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 1
1 rsquare ]
2 le <=
3 char 'l'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'e'
1 comma ,
3 char 'l'
1 comma ,
3 char 's'
1 comma ,
3 char 'e'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 10
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'e'
1 comma ,
3 char 'x'
1 comma ,
3 char 'i'
1 comma ,
3 char 't'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 12
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'p'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'f'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'f'
1 comma ,
3 char 'r'
1 comma ,
3 char 'e'
1 comma ,
3 char 'e'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 15
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'n'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'n'
1 comma ,
3 char 'u'
1 comma ,
3 char 'l'
1 comma ,
3 char 'l'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 22
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'p'
1 comma ,
3 char 'a'
1 comma ,
3 char 'i'
1 comma ,
3 char 'r'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 24
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 's'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'r'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'r'
1 comma ,
3 char 'e'
1 comma ,
3 char 'a'
1 comma ,
3 char 'd'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 27
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 's'
1 comma ,
3 char 'k'
1 comma ,
3 char 'i'
1 comma ,
3 char 'p'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 29
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 1
1 rsquare ]
2 le <=
3 char 'h'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 't'
1 comma ,
3 char 'h'
1 comma ,
3 char 'e'
1 comma ,
3 char 'n'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 32
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 't'
1 comma ,
3 char 'r'
1 comma ,
3 char 'u'
1 comma ,
3 char 'e'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 33
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
4 identifier lenn
2 le <=
1 number 5
4 then then
2 if if
4 identifier lenn
2 eq ==
1 number 5
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'f'
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'b'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'b'
1 comma ,
3 char 'e'
1 comma ,
3 char 'g'
1 comma ,
3 char 'i'
1 comma ,
3 char 'n'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
1 number 3
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'f'
1 comma ,
3 char 'a'
1 comma ,
3 char 'l'
1 comma ,
3 char 's'
1 comma ,
3 char 'e'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 13
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'p'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'p'
1 comma ,
3 char 'r'
1 comma ,
3 char 'i'
1 comma ,
3 char 'n'
1 comma ,
3 char 't'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 25
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'w'
1 comma ,
3 char 'h'
1 comma ,
3 char 'i'
1 comma ,
3 char 'l'
1 comma ,
3 char 'e'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 34
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
4 identifier lenn
2 le <=
1 number 6
4 then then
2 if if
4 identifier lenn
2 eq ==
1 number 6
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'r'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'r'
1 comma ,
3 char 'e'
1 comma ,
3 char 't'
1 comma ,
3 char 'u'
1 comma ,
3 char 'r'
1 comma ,
3 char 'n'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 28
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 's'
1 comma ,
3 char 't'
1 comma ,
3 char 'r'
1 comma ,
3 char 'i'
1 comma ,
3 char 'n'
1 comma ,
3 char 'g'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 31
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
4 identifier lenn
2 eq ==
1 number 7
4 then then
2 if if
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 number 0
1 rsquare ]
2 le <=
3 char 'n'
4 then then
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'n'
1 comma ,
3 char 'e'
1 comma ,
3 char 'w'
1 comma ,
3 char 'p'
1 comma ,
3 char 'a'
1 comma ,
3 char 'i'
1 comma ,
3 char 'r'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 21
4 else else
4 skip skip
2 fi fi
4 else else
4 char char
1 lsquare [
1 rsquare ]
3 identifier exp
1 assign =
1 lsquare [
3 char 'p'
1 comma ,
3 char 'r'
1 comma ,
3 char 'i'
1 comma ,
3 char 'n'
1 comma ,
3 char 't'
1 comma ,
3 char 'l'
1 comma ,
3 char 'n'
1 rsquare ]
1 semi ;
4 bool bool
2 identifier eq
1 assign =
4 call call
5 identifier streq
1 lparen (
3 identifier str
1 comma ,
5 identifier start
1 comma ,
4 identifier lenn
1 comma ,
3 identifier exp
1 rparen )
1 semi ;
4 free free
3 identifier exp
1 semi ;
2 if if
2 identifier eq
4 then then
6 return return
2 number 26
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
1 semi ;
6 return return
1 number 0
3 end end
4 bool bool
5 identifier streq
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
3 identifier dyn
1 comma ,
3 int int
5 identifier start
1 comma ,
3 int int
4 identifier lenn
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
6 identifier static
1 rparen )
2 is is
3 int int
1 identifier i
1 assign =
1 number 0
1 semi ;
5 while while
1 identifier i
1 lt <
4 identifier lenn
2 do do
2 if if
3 identifier dyn
1 lsquare [
5 identifier start
1 plus +
1 identifier i
1 rsquare ]
2 ne !=
6 identifier static
1 lsquare [
1 identifier i
1 rsquare ]
4 then then
6 return return
5 false false
4 else else
1 identifier i
1 assign =
1 identifier i
1 plus +
1 number 1
2 fi fi
4 done done
1 semi ;
6 return return
4 true true
3 end end
4 char char
7 identifier advance
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 bool bool
1 identifier b
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier b
4 then then
5 print print
16 string "Unexpected EOF"
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
2 number 19
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
4 else else
4 skip skip
2 fi fi
1 semi ;
4 char char
3 identifier ret
1 assign =
4 call call
4 identifier peek
1 lparen (
4 identifier self
1 rparen )
1 semi ;
3 snd snd
9 identifier __fstself
1 assign =
7 identifier current
1 plus +
1 number 1
1 semi ;
7 identifier current
1 assign =
7 identifier current
1 plus +
1 number 1
1 semi ;
2 if if
7 identifier current
2 ge >=
3 len len
6 identifier source
1 lsquare [
12 identifier logical_line
1 rsquare ]
4 then then
3 fst fst
9 identifier __fstself
1 assign =
12 identifier logical_line
1 plus +
1 number 1
1 semi ;
12 identifier logical_line
1 assign =
12 identifier logical_line
1 plus +
1 number 1
1 semi ;
3 snd snd
9 identifier __fstself
1 assign =
1 number 0
1 semi ;
7 identifier current
1 assign =
1 number 0
4 else else
4 skip skip
2 fi fi
1 semi ;
6 return return
3 identifier ret
3 end end
4 char char
4 identifier peek
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 bool bool
1 identifier b
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier b
4 then then
7 println println
16 string "Unexpected EOF"
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
2 number 37
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
4 else else
4 skip skip
2 fi fi
1 semi ;
2 if if
3 len len
6 identifier source
1 lsquare [
12 identifier logical_line
1 rsquare ]
2 eq ==
1 number 0
4 then then
6 return return
4 char '\n'
4 else else
6 return return
6 identifier source
1 lsquare [
12 identifier logical_line
1 rsquare ]
1 lsquare [
7 identifier current
1 rsquare ]
2 fi fi
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
11 identifier skipComment
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
5 while while
4 true true
2 do do
4 char char
1 identifier c
1 assign =
4 call call
4 identifier peek
1 lparen (
4 identifier self
1 rparen )
1 semi ;
4 bool bool
9 identifier is_at_end
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 eq ==
4 char '\n'
2 or ||
9 identifier is_at_end
4 then then
6 return return
4 null null
4 else else
4 char char
4 identifier _nop
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
2 fi fi
4 done done
1 semi ;
6 return return
4 null null
3 end end
4 bool bool
7 identifier isAtEnd
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
6 return return
6 identifier source
1 lsquare [
12 identifier logical_line
1 rsquare ]
2 eq ==
8 identifier sentinal
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
14 identifier skipWhitespace
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
5 while while
4 true true
2 do do
4 bool bool
7 identifier isAtEnd
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
7 identifier isAtEnd
4 then then
6 return return
4 null null
4 else else
4 skip skip
2 fi fi
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier __nop
1 assign =
4 call call
11 identifier lexer_print
1 lparen (
4 identifier self
1 rparen )
1 semi ;
4 char char
1 identifier c
1 assign =
4 call call
4 identifier peek
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 eq ==
3 char ' '
2 or ||
1 identifier c
2 eq ==
4 char '\t'
2 or ||
1 identifier c
2 eq ==
4 char '\n'
2 or ||
1 identifier c
2 eq ==
4 char '\r'
4 then then
4 char char
4 identifier _nop
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
4 else else
2 if if
1 identifier c
2 eq ==
3 char '#'
4 then then
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier __nop
1 assign =
4 call call
11 identifier skipComment
1 lparen (
4 identifier self
1 rparen )
4 else else
6 return return
4 null null
2 fi fi
2 fi fi
4 done done
1 semi ;
6 return return
4 null null
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
9 identifier makeToken
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 comma ,
3 int int
5 identifier ttype
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
10 identifier token_ctor
1 lparen (
5 identifier ttype
1 comma ,
5 identifier start
1 comma ,
7 identifier current
1 minus -
5 identifier start
1 comma ,
6 identifier source
1 lsquare [
12 identifier logical_line
1 rsquare ]
1 rparen )
1 semi ;
6 return return
5 identifier __ret
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
9 identifier lexer_new
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
10 identifier lexer_ctor
1 lparen (
6 identifier source
1 comma ,
8 identifier sentinal
1 comma ,
1 number 0
1 comma ,
1 number 0
1 comma ,
1 number 0
1 rparen )
1 semi ;
6 return return
5 identifier __ret
3 end end
4 bool bool
5 identifier match
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 comma ,
4 char char
8 identifier expected
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 bool bool
7 identifier isAtEnd
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
7 identifier isAtEnd
4 then then
6 return return
5 false false
4 else else
4 skip skip
2 fi fi
1 semi ;
4 char char
1 identifier c
1 assign =
4 call call
4 identifier peek
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 ne !=
8 identifier expected
4 then then
6 return return
5 false false
4 else else
4 skip skip
2 fi fi
1 semi ;
3 snd snd
9 identifier __fstself
1 assign =
7 identifier current
1 plus +
1 number 1
1 semi ;
7 identifier current
1 assign =
7 identifier current
1 plus +
1 number 1
1 semi ;
6 return return
4 true true
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
10 identifier next_token
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier __nop
1 assign =
4 call call
14 identifier skipWhitespace
1 lparen (
4 identifier self
1 rparen )
1 semi ;
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
3 snd snd
12 identifier __sndsndself
1 assign =
7 identifier current
1 semi ;
5 identifier start
1 assign =
7 identifier current
1 semi ;
4 bool bool
7 identifier isAtEnd
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
7 identifier isAtEnd
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
1 number 2
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
1 semi ;
4 char char
1 identifier c
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
1 semi ;
4 bool bool
1 identifier b
1 assign =
4 call call
7 identifier isAlpha
1 lparen (
1 identifier c
1 rparen )
1 semi ;
2 if if
1 identifier b
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
10 identifier identifier
1 lparen (
4 identifier self
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
1 semi ;
1 identifier b
1 assign =
4 call call
7 identifier isDigit
1 lparen (
1 identifier c
1 rparen )
1 semi ;
2 if if
1 identifier b
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
6 identifier number
1 lparen (
4 identifier self
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
1 semi ;
2 if if
1 identifier c
2 le <=
3 char '+'
4 then then
2 if if
1 identifier c
2 le <=
3 char '&'
4 then then
2 if if
1 identifier c
2 le <=
4 char '\"'
4 then then
2 if if
1 identifier c
2 le <=
3 char '!'
4 then then
2 if if
1 identifier c
2 eq ==
3 char '!'
4 then then
4 bool bool
4 identifier isEq
1 assign =
4 call call
5 identifier match
1 lparen (
4 identifier self
1 comma ,
3 char '='
1 rparen )
1 semi ;
2 if if
4 identifier isEq
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 53
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 42
1 rparen )
1 semi ;
6 return return
5 identifier __ret
2 fi fi
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 eq ==
4 char '\"'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier stringLit
1 lparen (
4 identifier self
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '%'
4 then then
2 if if
1 identifier c
2 eq ==
3 char '%'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 46
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 eq ==
3 char '&'
4 then then
1 identifier c
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 eq ==
3 char '&'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 54
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '('
4 then then
2 if if
1 identifier c
2 le <=
4 char '\''
4 then then
2 if if
1 identifier c
2 eq ==
4 char '\''
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
7 identifier charLit
1 lparen (
4 identifier self
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 eq ==
3 char '('
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 35
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char ')'
4 then then
2 if if
1 identifier c
2 eq ==
3 char ')'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 36
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '*'
4 then then
2 if if
1 identifier c
2 eq ==
3 char '*'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 44
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 eq ==
3 char '+'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 47
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '<'
4 then then
2 if if
1 identifier c
2 le <=
3 char '-'
4 then then
2 if if
1 identifier c
2 le <=
3 char ','
4 then then
2 if if
1 identifier c
2 eq ==
3 char ','
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 39
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 eq ==
3 char '-'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 43
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '/'
4 then then
2 if if
1 identifier c
2 eq ==
3 char '/'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 45
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char ';'
4 then then
2 if if
1 identifier c
2 eq ==
3 char ';'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 38
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 eq ==
3 char '<'
4 then then
4 bool bool
4 identifier isEq
1 assign =
4 call call
5 identifier match
1 lparen (
4 identifier self
1 comma ,
3 char '='
1 rparen )
1 semi ;
2 if if
4 identifier isEq
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 51
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 50
1 rparen )
1 semi ;
6 return return
5 identifier __ret
2 fi fi
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '>'
4 then then
2 if if
1 identifier c
2 le <=
3 char '='
4 then then
2 if if
1 identifier c
2 eq ==
3 char '='
4 then then
4 bool bool
4 identifier isEq
1 assign =
4 call call
5 identifier match
1 lparen (
4 identifier self
1 comma ,
3 char '='
1 rparen )
1 semi ;
2 if if
4 identifier isEq
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 52
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 37
1 rparen )
1 semi ;
6 return return
5 identifier __ret
2 fi fi
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 eq ==
3 char '>'
4 then then
4 bool bool
4 identifier isEq
1 assign =
4 call call
5 identifier match
1 lparen (
4 identifier self
1 comma ,
3 char '='
1 rparen )
1 semi ;
2 if if
4 identifier isEq
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 49
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 48
1 rparen )
1 semi ;
6 return return
5 identifier __ret
2 fi fi
4 else else
4 skip skip
2 fi fi
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '['
4 then then
2 if if
1 identifier c
2 eq ==
3 char '['
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 40
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char ']'
4 then then
2 if if
1 identifier c
2 eq ==
3 char ']'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 41
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
2 if if
1 identifier c
2 le <=
3 char '|'
4 then then
1 identifier c
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 eq ==
3 char '|'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 55
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
2 fi fi
1 semi ;
7 println println
13 string "Lexer error"
1 semi ;
5 print print
11 string "char = \'"
1 semi ;
5 print print
1 identifier c
1 semi ;
5 print print
12 string "\' (ascii "
1 semi ;
5 print print
3 ord ord
1 identifier c
1 semi ;
7 println println
3 string ")"
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
3 number 262
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
10 identifier identifier
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 bool bool
3 identifier run
1 assign =
4 true true
1 semi ;
5 while while
3 identifier run
2 do do
4 char char
1 identifier c
1 assign =
4 call call
4 identifier peek
1 lparen (
4 identifier self
1 rparen )
1 semi ;
4 bool bool
7 identifier isAlpha
1 assign =
4 call call
7 identifier isAlpha
1 lparen (
1 identifier c
1 rparen )
1 semi ;
4 bool bool
7 identifier isDigit
1 assign =
4 call call
7 identifier isDigit
1 lparen (
1 identifier c
1 rparen )
1 semi ;
2 if if
7 identifier isAlpha
2 or ||
7 identifier isDigit
4 then then
4 char char
4 identifier _nop
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
4 else else
3 identifier run
1 assign =
5 false false
2 fi fi
4 done done
1 semi ;
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier ttype
1 assign =
4 call call
15 identifier identifier_kind
1 lparen (
6 identifier source
1 lsquare [
12 identifier logical_line
1 rsquare ]
1 comma ,
5 identifier start
1 comma ,
7 identifier current
1 minus -
5 identifier start
1 rparen )
1 semi ;
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
5 identifier ttype
1 rparen )
1 semi ;
6 return return
5 identifier __ret
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier number
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 bool bool
3 identifier run
1 assign =
4 true true
1 semi ;
5 while while
3 identifier run
2 do do
4 char char
1 identifier c
1 assign =
4 call call
4 identifier peek
1 lparen (
4 identifier self
1 rparen )
1 semi ;
4 bool bool
7 identifier isDigit
1 assign =
4 call call
7 identifier isDigit
1 lparen (
1 identifier c
1 rparen )
1 semi ;
2 if if
7 identifier isDigit
4 then then
4 char char
4 identifier _nop
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
4 else else
3 identifier run
1 assign =
5 false false
2 fi fi
4 done done
1 semi ;
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
1 number 1
1 rparen )
1 semi ;
6 return return
5 identifier __ret
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
9 identifier stringLit
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 bool bool
3 identifier iae
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
5 while while
1 not !
3 identifier iae
2 do do
4 char char
1 identifier c
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 eq ==
4 char '\"'
4 then then
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
2 number 31
1 rparen )
1 semi ;
6 return return
5 identifier __ret
4 else else
4 skip skip
2 fi fi
1 semi ;
2 if if
1 identifier c
2 eq ==
4 char '\\'
4 then then
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier __nop
1 assign =
4 call call
15 identifier escape_sequence
1 lparen (
4 identifier self
1 rparen )
4 else else
4 skip skip
2 fi fi
1 semi ;
2 if if
1 identifier c
2 eq ==
4 char '\''
4 then then
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
3 number 308
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
4 else else
4 skip skip
2 fi fi
1 semi ;
3 identifier iae
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
4 done done
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
3 number 313
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
3 end end
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
7 identifier charLit
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 bool bool
1 identifier b
1 assign =
4 call call
7 identifier isAtEnd
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier b
4 then then
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
3 number 319
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
4 else else
4 skip skip
2 fi fi
1 semi ;
4 char char
1 identifier c
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 eq ==
4 char '\''
2 or ||
1 identifier c
2 eq ==
4 char '\"'
4 then then
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
3 number 323
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
4 else else
4 skip skip
2 fi fi
1 semi ;
2 if if
1 identifier c
2 eq ==
4 char '\\'
4 then then
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier __nop
1 assign =
4 call call
15 identifier escape_sequence
1 lparen (
4 identifier self
1 rparen )
4 else else
4 skip skip
2 fi fi
1 semi ;
1 identifier c
1 assign =
4 call call
7 identifier advance
1 lparen (
4 identifier self
1 rparen )
1 semi ;
2 if if
1 identifier c
2 ne !=
4 char '\''
4 then then
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
3 number 330
1 comma ,
7 string "Error"
1 rparen )
1 semi ;
4 exit exit
1 number 1
4 else else
4 skip skip
2 fi fi
1 semi ;
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier __ret
1 assign =
4 call call
9 identifier makeToken
1 lparen (
4 identifier self
1 comma ,
1 number 6
1 rparen )
1 semi ;
6 return return
5 identifier __ret
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
15 identifier escape_sequence
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
6 identifier __exit
1 assign =
4 call call
9 identifier wacc_fail
1 lparen (
19 string "src/lexer.wacc.in"
1 comma ,
3 number 336
1 comma ,
15 string "Unimplemented"
1 rparen )
1 semi ;
4 exit exit
1 number 1
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
11 identifier print_token
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
4 identifier type
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
6 identifier length
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
3 int int
5 identifier start
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
5 print print
5 identifier start
1 semi ;
5 print print
3 string " "
1 semi ;
5 print print
6 identifier length
1 semi ;
6 string string
4 identifier kind
1 assign =
4 call call
14 identifier token_type_str
1 lparen (
4 identifier type
1 rparen )
1 semi ;
5 print print
3 string " "
1 semi ;
5 print print
4 identifier kind
1 semi ;
5 print print
3 string " "
1 semi ;
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier __nop
1 assign =
4 call call
8 identifier printStr
1 lparen (
6 identifier source
1 comma ,
5 identifier start
1 comma ,
6 identifier length
1 rparen )
1 semi ;
7 println println
2 string ""
1 semi ;
6 return return
4 null null
3 end end
3 int int
10 identifier token_type
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
4 identifier type
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
6 identifier length
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
4 char char
1 lsquare [
1 rsquare ]
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
3 int int
5 identifier start
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
6 return return
4 identifier type
3 end end
4 char char
1 lsquare [
1 rsquare ]
10 identifier alloc_line
1 lparen (
1 rparen )
2 is is
4 char char
1 lsquare [
1 rsquare ]
1 identifier r
1 assign =
1 lsquare [
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 comma ,
3 char ' '
1 rsquare ]
1 semi ;
6 return return
1 identifier r
3 end end
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
11 identifier alloc_lines
1 lparen (
1 rparen )
2 is is
4 char char
1 lsquare [
1 rsquare ]
1 identifier l
1 assign =
1 lsquare [
1 rsquare ]
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 identifier r
1 assign =
1 lsquare [
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 comma ,
1 identifier l
1 rsquare ]
1 semi ;
6 return return
1 identifier r
3 end end
6 extern extern
3 int int
7 identifier getchar
1 lparen (
1 rparen )
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
8 identifier read_all
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 rparen )
2 is is
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
5 identifier lines
1 assign =
4 call call
11 identifier alloc_lines
1 lparen (
1 rparen )
1 semi ;
3 int int
8 identifier linesPos
1 assign =
1 number 0
1 semi ;
3 int int
7 identifier linePos
1 assign =
1 number 0
1 semi ;
4 bool bool
7 identifier running
1 assign =
4 true true
1 semi ;
4 bool bool
8 identifier inStrChr
1 assign =
5 false false
1 semi ;
4 bool bool
8 identifier inEscape
1 assign =
5 false false
1 semi ;
5 while while
7 identifier running
2 do do
3 int int
1 identifier c
1 assign =
4 call call
7 identifier getchar
1 lparen (
1 rparen )
1 semi ;
2 if if
1 identifier c
2 eq ==
1 minus -
1 number 1
4 then then
7 identifier running
1 assign =
5 false false
4 else else
2 if if
1 identifier c
2 eq ==
3 ord ord
4 char '\n'
4 then then
2 if if
8 identifier inStrChr
4 then then
5 identifier lines
1 lsquare [
8 identifier linesPos
1 rsquare ]
1 lsquare [
7 identifier linePos
1 rsquare ]
1 assign =
3 chr chr
1 identifier c
4 else else
8 identifier linesPos
1 assign =
8 identifier linesPos
1 plus +
1 number 1
1 semi ;
7 identifier linePos
1 assign =
1 number 0
2 fi fi
4 else else
2 if if
3 len len
5 identifier lines
1 lsquare [
8 identifier linesPos
1 rsquare ]
2 eq ==
1 number 0
4 then then
5 identifier lines
1 lsquare [
8 identifier linesPos
1 rsquare ]
1 assign =
4 call call
10 identifier alloc_line
1 lparen (
1 rparen )
4 else else
4 skip skip
2 fi fi
1 semi ;
5 identifier lines
1 lsquare [
8 identifier linesPos
1 rsquare ]
1 lsquare [
7 identifier linePos
1 rsquare ]
1 assign =
3 chr chr
1 identifier c
1 semi ;
2 if if
1 lparen (
1 identifier c
2 eq ==
3 ord ord
4 char '\''
2 or ||
1 identifier c
2 eq ==
3 ord ord
4 char '\"'
1 rparen )
2 and &&
1 not !
8 identifier inEscape
4 then then
8 identifier inStrChr
1 assign =
1 not !
8 identifier inStrChr
4 else else
4 skip skip
2 fi fi
1 semi ;
2 if if
8 identifier inStrChr
2 and &&
1 identifier c
2 eq ==
3 ord ord
4 char '\\'
4 then then
8 identifier inEscape
1 assign =
1 not !
8 identifier inEscape
4 else else
4 skip skip
2 fi fi
2 fi fi
2 fi fi
1 semi ;
7 identifier linePos
1 assign =
7 identifier linePos
1 plus +
1 number 1
4 done done
1 semi ;
5 identifier lines
1 lsquare [
8 identifier linesPos
1 plus +
1 number 1
1 rsquare ]
1 assign =
8 identifier sentinal
1 semi ;
6 return return
5 identifier lines
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
8 identifier printStr
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
3 identifier str
1 comma ,
3 int int
5 identifier start
1 comma ,
3 int int
4 identifier lenn
1 rparen )
2 is is
3 int int
1 identifier i
1 assign =
1 number 0
1 semi ;
5 while while
1 lparen (
1 identifier i
1 lt <
4 identifier lenn
1 rparen )
2 do do
5 print print
3 identifier str
1 lsquare [
5 identifier start
1 plus +
1 identifier i
1 rsquare ]
1 semi ;
1 identifier i
1 assign =
1 identifier i
1 plus +
1 number 1
4 done done
1 semi ;
6 return return
4 null null
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
11 identifier lexer_print
1 lparen (
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
4 identifier self
1 rparen )
2 is is
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
6 identifier __self
1 assign =
4 identifier self
1 semi ;
4 pair pair
1 lparen (
3 int int
1 comma ,
3 int int
1 rparen )
9 identifier __fstself
1 assign =
3 fst fst
6 identifier __self
1 semi ;
3 int int
12 identifier logical_line
1 assign =
3 fst fst
9 identifier __fstself
1 semi ;
3 int int
7 identifier current
1 assign =
3 snd snd
9 identifier __fstself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 comma ,
4 pair pair
1 rparen )
9 identifier __sndself
1 assign =
3 snd snd
6 identifier __self
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
8 identifier sentinal
1 assign =
3 fst fst
9 identifier __sndself
1 semi ;
4 pair pair
1 lparen (
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 rparen )
12 identifier __sndsndself
1 assign =
3 snd snd
9 identifier __sndself
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
6 identifier source
1 assign =
3 fst fst
12 identifier __sndsndself
1 semi ;
3 int int
5 identifier start
1 assign =
3 snd snd
12 identifier __sndsndself
1 semi ;
5 print print
17 string "Lexer{current: "
1 semi ;
5 print print
7 identifier current
1 semi ;
5 print print
11 string ", start: "
1 semi ;
5 print print
5 identifier start
1 semi ;
5 print print
18 string ", logical_line: "
1 semi ;
5 print print
12 identifier logical_line
1 semi ;
7 println println
3 string "}"
1 semi ;
6 return return
4 null null
3 end end
4 pair pair
1 lparen (
4 bool bool
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 comma ,
3 int int
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
1 rparen )
5 identifier __nop
1 assign =
4 null null
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
12 identifier end_of_input
1 assign =
1 lsquare [
1 rsquare ]
1 semi ;
4 char char
1 lsquare [
1 rsquare ]
1 lsquare [
1 rsquare ]
5 identifier input
1 assign =
4 call call
8 identifier read_all
1 lparen (
12 identifier end_of_input
1 rparen )
1 semi ;
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
5 identifier lexer
1 assign =
4 call call
9 identifier lexer_new
1 lparen (
5 identifier input
1 comma ,
12 identifier end_of_input
1 rparen )
1 semi ;
4 bool bool
3 identifier run
1 assign =
4 true true
1 semi ;
5 while while
3 identifier run
2 do do
4 pair pair
1 lparen (
4 pair pair
1 comma ,
4 pair pair
1 rparen )
1 identifier t
1 assign =
4 call call
10 identifier next_token
1 lparen (
5 identifier lexer
1 rparen )
1 semi ;
5 identifier __nop
1 assign =
4 call call
11 identifier print_token
1 lparen (
1 identifier t
1 rparen )
1 semi ;
3 int int
2 identifier tt
1 assign =
4 call call
10 identifier token_type
1 lparen (
1 identifier t
1 rparen )
1 semi ;
3 identifier run
1 assign =
2 identifier tt
2 ne !=
1 number 2
1 semi ;
5 identifier __nop
1 assign =
4 call call
11 identifier lexer_print
1 lparen (
5 identifier lexer
1 rparen )
4 done done
1 semi ;
4 skip skip
3 end end
0 eof 
